/*
  Copyright (c) 2012 Azavea, Inc.
 
  This file is part of ACS Alchemist.

  ACS Alchemist is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ACS Alchemist is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ACS Alchemist.  If not, see <http://www.gnu.org/licenses/>.
*/

using NUnit.Framework;
using log4net;
using System.IO;
using System.Collections.Generic;
using Azavea.NijPredictivePolicing.Test.Helpers;
using Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer;
using GeoAPI.Geometries;
using Azavea.NijPredictivePolicing.ACSAlchemistLibrary;
using Azavea.NijPredictivePolicing.Common;
using Azavea.NijPredictivePolicing.Common.DB;
using System.Text;using System;using log4net.Core;
using System.Data;
using System.Data.Common;
using ProjNet.CoordinateSystems;
namespace Azavea.NijPredictivePolicing.Test.ACSAlchemistLibrary
{
    [TestFixture]
    public class AcsDataManagerTests : BaseTest
    {
        /// <summary>
        /// Place to dump files generated by tests
        /// </summary>
        protected const string OutputDir = @"output\";

        /// <summary>
        /// Default variables to use for sequence file tests
        /// </summary>
        /// <remarks>
        /// CENSUS_TABLE_ID, NAME, COLNO, SEQNO
        /// </remarks>
        public readonly string[] TestVariables = new string[] {
            "B00001001,ALLPOP,6,9",
            "B01001002,TOTALMALE,7,10",
            "B01001003,TOTMALE1,8,10",
            "B01001026,TOTALFEMALE,31,10"
        };

        [TestFixtureSetUp]
        public void Init()
        {
            _log = LogHelpers.ResetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

            if (!Directory.Exists(OutputDir))
            {
                Directory.CreateDirectory(OutputDir);
            }
        }

        [Test]
        public void GetShapefileFeatures()
        {
            var features = new List<IGeometry>();
            var features2 = new List<IGeometry>();

            var man = GetManager();

            features = man.GetFilteringGeometries(GetShapePath(man, "DoesNotExist.shp"), 
                GeographicCoordinateSystem.WGS84);
            Assert.AreEqual(null, features, "Shapefile shouldn't exist!");

            features = man.GetFilteringGeometries(GetShapePath(man, "bg42_d00.shp"), GeographicCoordinateSystem.WGS84);
            Assert.AreEqual(null, features, "Shapefile shouldn't exist!");

            features = man.GetFilteringGeometries(GetShapePath(man, "bg42_d00_nosrid.shp"), 
                GeographicCoordinateSystem.WGS84);

            Assert.Greater(features.Count, 0, "Should be more than zero features!");

            features = man.GetFilteringGeometries(GetShapePath(man, "bg42_d00_srid.shp"), 
                GeographicCoordinateSystem.WGS84);
            Assert.Greater(features.Count, 0, "Should be more than zero features!");

            features2 = man.GetFilteringGeometries(GetShapePath(man, "bg42_d00_srid.shp"),
                GeographicCoordinateSystem.WGS84);
        }

        [Test]
        public void ImportVariablesFile()
        {
            var man = GetManager();
            man.WorkingPath = Path.Combine(man.WorkingPath, "ColumnFiles");
            man.CheckColumnMappingsFile();

            var invalidInputs = new string[] {
                "Invalid101Lines.txt",
                "InvalidAllDupes.txt",
                "InvalidEmpty.txt",
                "InvalidLotsOfDupes.txt",
                "InvalidMoECollisions.txt",
                "InvalidReservedCollisions.txt",
                "InvalidTruncCollisions.txt"
            };

            for (int i = 0; i < invalidInputs.Length; i++)
            {
                invalidInputs[i] = Path.Combine(man.WorkingPath, invalidInputs[i]);
            }

            using (var conn = man.DbClient.GetConnection())
            {
                if (!DataClient.HasTable(conn, man.DbClient, "columnMappings"))
                {
                    if (!man.CreateColumnMappingsTable(conn))
                    {
                        Assert.Fail("Could not import sequence files");
                    }
                }

                /* should fail for assert to pass*/
                foreach (string file in invalidInputs)
                {
                    AssertFailedImport(file, man, conn);
                }
            }
        }

        [Test]
        public void TestRead2009SequenceFiles()
        {
            string testYear = "2009";
            TestReadSequenceFiles(testYear, TestVariables);
        }

        [Test]
        public void TestRead2010SequenceFiles()
        {
            string testYear = "2010";
            TestReadSequenceFiles(testYear, TestVariables);
        }

        [Ignore("TODO: These seem to have different expected values than the previous years")]
        [Test]
        public void TestRead2011SequenceFiles()
        {
            string testYear = "2011";
            TestReadSequenceFiles(testYear, TestVariables);
        }

        [Ignore("TODO: These seem to have different expected values than the previous years")]
        [Test]
        public void TestRead2012SequenceFiles()
        {
            string testYear = "2012";
            TestReadSequenceFiles(testYear, TestVariables);
        }


        /// <summary>
        /// Ensure we're grabbing the correct columns given the requested variable name
        /// </summary>
        public void TestReadSequenceFiles(string year, string[] testVariables)
        {
            //Grab our 'Wyoming' manager object
            var man = GetManager(year);

            Assert.IsTrue(man.CheckColumnMappingsFile(), "Couldn't get required file");
            Assert.IsTrue(man.CheckBlockGroupFile(), "Couldn't get required file");


            using (var conn = man.DbClient.GetConnection())
            {

                if (!man.CreateColumnMappingsTable(conn))
                {
                    Assert.Fail("Could not import sequence files");
                }

                string sqlTemplate = @"SELECT    columnMappings.CENSUS_TABLE_ID, 
                                  columnMappings.COLNO, 
                                  columnMappings.SEQNO
                                  
                        FROM      columnMappings
                        WHERE     columnMappings.CENSUS_TABLE_ID = '{0}';";

                foreach (string testRow in testVariables)
                {
                    string[] chunks = testRow.Split(',');
                    int expectedColNo = Utilities.GetAs(chunks[2], -1);
                    int expectedSeqNo = Utilities.GetAs(chunks[3], -1);

                    string sql = string.Format(sqlTemplate, chunks[0]);
                    DataTable dt = DataClient.GetMagicTable(conn, man.DbClient, sql);

                    Assert.IsNotNull(dt, "DataTable was null!");
                    Assert.IsTrue(dt.Rows.Count > 0, "DataTable was empty!");

                    int colNo = Utilities.GetAs(dt.Rows[0]["COLNO"], -1);
                    int seqNo = Utilities.GetAs(dt.Rows[0]["SEQNO"], -1);

                
                    _log.DebugFormat("Column, Sequence for {0} is {1}, {2}", chunks[0], colNo, seqNo);

                    Assert.AreEqual(expectedColNo, colNo, "COLUMN NUMBER MISMATCH for variable " + chunks[0]);
                    Assert.AreEqual(expectedSeqNo, seqNo, "COLUMN NUMBER MISMATCH for variable " + chunks[0]);
                }
            }
        }



        [Test]
        public void ImportVariablesFileSuccesses()
        {            
            var man = GetManager();
            man.WorkingPath = Path.Combine(man.WorkingPath, "ColumnFiles");
            man.CheckColumnMappingsFile();

            /************************************************************************************/
            string Valid100Lines = Path.Combine(man.WorkingPath, "Valid100Lines.txt");
            string ValidNoNames = Path.Combine(man.WorkingPath, "ValidNoNames.txt");
            /************************************************************************************/


            using (var conn = man.DbClient.GetConnection())
            {
                if (!DataClient.HasTable(conn, man.DbClient, "columnMappings"))
                {
                    if (!man.CreateColumnMappingsTable(conn))
                    {
                        Assert.Fail("Could not import sequence files");
                    }
                }

                /* Successes */
                DataTable dt = null;

                //105 should really be 100, but there are duplicate rows in columnMappings
                //See #19869
                //If/when that bug gets fixed, 105 should be changed to 100 and this comment deleted
                Assert.IsTrue(File.Exists(Valid100Lines), "Could not find test file " + Valid100Lines);
                man.DesiredVariablesFilename = Valid100Lines;
                dt = man.GetRequestedVariables(conn);
                Assert.AreEqual(105, dt.Rows.Count,
                    "Unexpected number of rows returned for file " + Valid100Lines);


                Assert.IsTrue(File.Exists(ValidNoNames), "Could not find test file " + ValidNoNames);
                man.DesiredVariablesFilename = ValidNoNames;
                dt = man.GetRequestedVariables(conn);
                Assert.AreEqual(105, dt.Rows.Count,
                    "Unexpected number of rows returned for file " + ValidNoNames);

            }
        }


        private void AssertFailedImport(string filename, AcsDataManager man, DbConnection conn)
        {
            Assert.IsTrue(File.Exists(filename), "Could not find test file " + filename);
            man.DesiredVariablesFilename = filename;

            DataTable dt = man.GetRequestedVariables(conn);
            Assert.IsTrue(dt == null, "Non-null DataTable returned for file " + filename);
        }


        /// <summary>        
        /// Test to ensure importer correctly detects and bails on too many requested columns        
        /// </summary>        
        [Test]
        public void CheckTooManyColumnsFail()
        {
            string basePath = FileUtilities.PathEnsure(BaseDir, "TestData");
            string TooManyVariablesFile = Path.Combine(basePath, "TooManyColumns.txt");

            if (!File.Exists(TooManyVariablesFile))
            {
                int maxColumns = 255, max = (maxColumns / 2) + 1;
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < max; i++)
                {
                    sb.Append("COLUMN").Append(i).Append(Environment.NewLine);
                }
                File.WriteAllText(TooManyVariablesFile, sb.ToString());
            }

            var manager = new AcsDataManager(AcsState.Wyoming);
            manager.WorkingPath = basePath;
            manager.DesiredVariablesFilename = TooManyVariablesFile;
            Assert.IsFalse(manager.CheckBuildVariableTable("TestTooMany"));
        }

        protected AcsDataManager GetManager()
        {
            return GetManager("2009");
        }

        protected AcsDataManager GetManager(string year)
        {
            AcsDataManager m = new AcsDataManager(AcsState.Wyoming, Path.Combine(BaseDir, "Working"), year);            
            m.WorkingPath = FileUtilities.PathEnsure(BaseDir, "TestData");

            string dbPath = FileUtilities.PathEnsure(m.WorkingPath, "database");
            m.DBFilename = FileUtilities.PathCombine(dbPath, Settings.CurrentAcsDirectory + ".sqlite");
            m.ShapePath = FileUtilities.PathEnsure(m.WorkingPath, "shapes");
            m.CurrentDataPath = m.WorkingPath;
            m.DbClient = DataClient.GetDefaultClient(m.DBFilename);

            return m;
        }


        protected string GetShapePath(AcsDataManager man, string filename)
        {
            return Path.Combine(man.ShapePath, Path.GetFileName(filename));
        }
    }
}
